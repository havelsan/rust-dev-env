use project_05::*;

#[test]
fn test_add() {
    let mut current_number = project_05::CurrentNumber { num: 6  };
    let mut a=current_number.add(15);
    a=current_number.add(3);
    assert_eq!(a,24);
}


#[test]
fn test_mocking_add() {
        use mockall::predicate;
        // The struct generated by `#[automock]` is always
        // called `MockX` where `X` is the name of the trait:
        let mut mock = MockCalc::new();

        // We need to configure the mock object.
        //
        // `expect_add` tells `mockall` that we are expecting
        // a function call to `add`
        mock.expect_add()
             // and our expected input/argument to `add` is 2
            .with(predicate::eq(2))
            // we will only call it 1 time
            .times(1)
            // and it will return the result of this closure
            .returning(|n| 2 + n);

        // The mock has been configured and will only work if
        // we call the `add` function with an argument of
        // `2`. It will return the result of 2+2 because the
        // `returning` closure adds `2` to whatever was input
        // to `add`. In this case the input will always be `2`
        // because we forced the mock to only accept `2` as
        // the argument, using `predicate`. Removing `predicate`
        // will allow the mock to calculate arbitrary values.
        assert_eq!(4, mock.add(2));
}
